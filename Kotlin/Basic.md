firebase

2강

var
일반적으로 통용되는 변수
언제든지 읽기 쓰기가 가능하다
val
선언시에만 초기화 가능
중간에 값을 변경할 수 없음.
const와 같다

변수에 null 값을 가질 수 없고 값을 무조건 초기화 시켜주어야 한다.

변수 선언시 null을 허용하는 nullable변수로 선언 할 수 있다.
var a: int? = null

null pointer exception이 발생할 수 있으므로 조심.

변수의 초기화를 늦추는 lateinit, lazy 속성도 있다.
-클래스에서 알려줌.

Long Type = 123L
16진수 = 0x1af
2진수 = 0b101010

double 은 123.5 혹은 지수표기법 : 123.5e10
Float 는 123.5f 혹은 123.5F

코틀린은 내부형을 UTF-16BE를 사용
char형은 2bytes의 메모리공간을 사용한다.
'a'
문자열 변수
val 변수명 :String = "문자열"
혹은
val 변수명 = """ 문자열 (줄바꿈, 특수문자 까지 그냥 포함)  """

논리형 Boolean




3강
형변환(type casting) [다른 자료형으로 바꿈]
논리형은 변환할 수 없다.

형변환 함수를 제공하고 있다
toByte()
toShort()
toInt()
toLong()
toFloat()
toDouble()
toChar()
(명시적형변환) - 변환될 자료형을 개발자가 직접 지정
암시적형변환 지원 X

배열
내부적으로 클래스 형태 Array<T>
선언
var 변수명 = arrayOf(배열에 저장할 값 ex)1,2,3,4,5)
비어있는 배열을 만들고 싶다면
var 변수명 = arrayOfNulls<자료형>
꺽쇠 안에 배열에 할당할 자료형을 지정한다 = Generic
배열이름[index] = 값


4강
타입추론(type inference)
변수나 함수들을 선언할 때나 연산이 이루어질 때 자료형을 코드에 명시하지 않아도 코틀린이 자동으로 추론해주는 기능

선언시 값을 할당해준다면 자료형을 적어줄 필요가 없다.


함수
특정한 동작을 하거나 원하는 결과값을 연산하는데 사용하는 기능
fun 함수명 (변수:자료형, a: Float, ...):반환자료형 {
    return 값
}

단일표현식함수(single-expression function)
변수에 결과값을 할당하듯 식을 할당하여 표현할 수 있다.
반환형의 타입추론도 가능하다.
fun 함수명 (변수1:자료형, 변수2:자료형) = 변수1 + 변수2


5강 비교연산자
if(조건식){ 실행식 }
else{ 실행식 }

비교연산자
부등호 < <= > >= !=
등호 ==
is 연산자 / !is 연산자  
좌측 변수가 우측 자료형에 호환되는지 여부를 체크하고 형 변환까지 한번에 진행시켜주는 
변수 is 자료형

다중조건문
switch문을 좀 더 편리하게 바꾼 기능
when(변수){
    값1 -> 실행구문
    값2 -> 실행구문
    is Long -> 실행구문 
    !is String -> 실행구문
    else -> default와 같은 실행구문
}
동작 대신 값을 반환하는 표현식으로 역할하게 할 수도 있음
변수에 값을 할당하거나 직접 값으로서 사용할 수가 있다.
변수 = when(변수){
    값1 -> 값
    값2 -> 값
    ...
}


Any자료형 어떤 자료형이든 상관없는 최상위 자료형


6강
반복문
조건이 참인경우반복을 유지
조건형 반복문
while
do...while
범위형 반복문
for
for(index[var등을 붙이지 않아도 된다] in 0..9) // index가 0에서 9까지, 증가값은 1
for(index in 0..9 step 다른값) // 증가값은 다른값
for(index in 9 downTo 0) // 9에서 0까지 1씩 반복되며 감소
for(index in 9 downTo 0 step 다른값) // 감소값이 다른값
char 자료형도 가능하다.
for(i in 'a'..'e')


증감연산자
증가연산자 (전위연산자, 후위연산자)
++변수 / 변수++
감소연산자
--변수 / 변수--

"" 안에 $변수 를 쓰면 변수값을 대신해서 출력



7강
흐름을 제어하는 키워드
반복문에 사용할 수 있는
break와 continue
다중반복문을 label로 지정해서 제어할 수 있다.
label이름@for
breakl@label이름

논리연산자
&& || !



8강 클래스 3회차걸쳐서

클래스
값과 그 값을 사용하는 기능들을 묶어놓은 것
코틀린 내부에서는 자료형 모두 클래스로 만들어져있다.

class 이름 (val name:String ...[속성을 뜻한다])

class 이름 (val name:String ...[속성을 뜻한다]){
    함수들
}

instance 선언
클래스이름(속성값들)
속성값에 접근
클래스이름.속성이름
함수 호출
클래스이름.함수이름



9강
클래스의 생성자
생성자 : 새로운 인스턴스를 만들기 위해 호출하는 함수
1. 인스턴스의 속성을 초기화
2. 인스턴스 생성시 구문을 수행

init 함수 // 패러미터나 반환형이 없는 특수한 함수
생성자를 통해 인스턴스가 만들어 질 때 호출되는 함수이다.
class 이름 (val name:String ...[속성을 뜻한다]){
    init{
        this.속성   //  인스턴스 자신의 속성이나 함수를 호출하기 위해 클래스 내부에서 사용되는 키워드
    }
}

기본 생성자 - 클래스를 만들 때 기본으로 선언하는
보조 생성자 - 필요에 따라 추가적으로 선언하는
기본 생성자와 다른형태의 생성자를 제공하여 인스턴스 생성시 편의를 제공하거나 추가적인 구문을 수행하는 기능을 제공하는 역할
class 이름 (val name:String ...[속성을 뜻한다]){
    init{
        this.속성   //  인스턴스 자신의 속성이나 함수를 호출하기 위해 클래스 내부에서 사용되는 키워드
    }
    constructor(속성이름: 속성변수형) : this(속성이름, 값){ // 보조생성자가 기본생성자를 호출하도록 하는 문구
        수행하는 기능
    }
}



10강
클래스의 상속
상속이 필요한 경우
1. 이미 존재하는 클래스를 확장하여 새로운 속성이나 함수를 추가
2. 여러개의 클래스의 공통점을 가진 클래스를 만들 때
수퍼 클래스 -> 서브 클래스

코틀린에서는 상속금지가 기본값이다.
open은 클래스가 상속될 수 있도록 클래스 선언시 붙여줄 수 있는 키워드 

ex)
class Animal(속성값들~){
    함수~

}
class Dog(var, val을 붙이면 속성으로 선언, 일반 패러미터로 수퍼클래스의 속성값들을 적준다. ): 수퍼클래스의 생성자[Animal(속성값들, "값")]{
    함수
}

상속 규칙
서브 클래스는 수퍼 클래스에 존재하는 속성과 같은이름의 속성을 가질 수 없다.
서브클래스가 생성될 때는 반드시 수퍼클래스의 생성자까지 호출되어야 한다.


11강
