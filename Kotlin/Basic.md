firebase

2강

var
일반적으로 통용되는 변수
언제든지 읽기 쓰기가 가능하다
val
선언시에만 초기화 가능
중간에 값을 변경할 수 없음.
const와 같다

변수에 null 값을 가질 수 없고 값을 무조건 초기화 시켜주어야 한다.

변수 선언시 null을 허용하는 nullable변수로 선언 할 수 있다.
var a: int? = null

null pointer exception이 발생할 수 있으므로 조심.

변수의 초기화를 늦추는 lateinit, lazy 속성도 있다.
-클래스에서 알려줌.

Long Type = 123L
16진수 = 0x1af
2진수 = 0b101010

double 은 123.5 혹은 지수표기법 : 123.5e10
Float 는 123.5f 혹은 123.5F

코틀린은 내부형을 UTF-16BE를 사용
char형은 2bytes의 메모리공간을 사용한다.
'a'
문자열 변수
val 변수명 :String = "문자열"
혹은
val 변수명 = """ 문자열 (줄바꿈, 특수문자 까지 그냥 포함)  """

논리형 Boolean




3강
형변환(type casting) [다른 자료형으로 바꿈]
논리형은 변환할 수 없다.

형변환 함수를 제공하고 있다
toByte()
toShort()
toInt()
toLong()
toFloat()
toDouble()
toChar()
(명시적형변환) - 변환될 자료형을 개발자가 직접 지정
암시적형변환 지원 X

배열
내부적으로 클래스 형태 Array<T>
선언
var 변수명 = arrayOf(배열에 저장할 값 ex)1,2,3,4,5)
비어있는 배열을 만들고 싶다면
var 변수명 = arrayOfNulls<자료형>
꺽쇠 안에 배열에 할당할 자료형을 지정한다 = Generic
배열이름[index] = 값


4강
타입추론(type inference)
변수나 함수들을 선언할 때나 연산이 이루어질 때 자료형을 코드에 명시하지 않아도 코틀린이 자동으로 추론해주는 기능

선언시 값을 할당해준다면 자료형을 적어줄 필요가 없다.


함수
특정한 동작을 하거나 원하는 결과값을 연산하는데 사용하는 기능
fun 함수명 (변수:자료형, a: Float, ...):반환자료형 {
    return 값
}

단일표현식함수(single-expression function)
변수에 결과값을 할당하듯 식을 할당하여 표현할 수 있다.
반환형의 타입추론도 가능하다.
fun 함수명 (변수1:자료형, 변수2:자료형) = 변수1 + 변수2


5강 비교연산자
if(조건식){ 실행식 }
else{ 실행식 }

비교연산자
부등호 < <= > >= !=
등호 ==
is 연산자 / !is 연산자  
좌측 변수가 우측 자료형에 호환되는지 여부를 체크하고 형 변환까지 한번에 진행시켜주는 
변수 is 자료형

다중조건문
switch문을 좀 더 편리하게 바꾼 기능
when(변수){
    값1 -> 실행구문
    값2 -> 실행구문
    is Long -> 실행구문 
    !is String -> 실행구문
    else -> default와 같은 실행구문
}
동작 대신 값을 반환하는 표현식으로 역할하게 할 수도 있음
변수에 값을 할당하거나 직접 값으로서 사용할 수가 있다.
변수 = when(변수){
    값1 -> 값
    값2 -> 값
    ...
}


Any자료형 어떤 자료형이든 상관없는 최상위 자료형


6강
반복문
조건이 참인경우반복을 유지
조건형 반복문
while
do...while
범위형 반복문
for
for(index[var등을 붙이지 않아도 된다] in 0..9) // index가 0에서 9까지, 증가값은 1
for(index in 0..9 step 다른값) // 증가값은 다른값
for(index in 9 downTo 0) // 9에서 0까지 1씩 반복되며 감소
for(index in 9 downTo 0 step 다른값) // 감소값이 다른값
char 자료형도 가능하다.
for(i in 'a'..'e')


증감연산자
증가연산자 (전위연산자, 후위연산자)
++변수 / 변수++
감소연산자
--변수 / 변수--

"" 안에 $변수 를 쓰면 변수값을 대신해서 출력



7강
흐름을 제어하는 키워드
반복문에 사용할 수 있는
break와 continue
다중반복문을 label로 지정해서 제어할 수 있다.
label이름@for
breakl@label이름

논리연산자
&& || !



8강 클래스 3회차걸쳐서

클래스
값과 그 값을 사용하는 기능들을 묶어놓은 것
코틀린 내부에서는 자료형 모두 클래스로 만들어져있다.

class 이름 (val name:String ...[속성을 뜻한다])

class 이름 (val name:String ...[속성을 뜻한다]){
    함수들
}

instance 선언
클래스이름(속성값들)
속성값에 접근
클래스이름.속성이름
함수 호출
클래스이름.함수이름



9강
클래스의 생성자
생성자 : 새로운 인스턴스를 만들기 위해 호출하는 함수
1. 인스턴스의 속성을 초기화
2. 인스턴스 생성시 구문을 수행

init 함수 // 패러미터나 반환형이 없는 특수한 함수
생성자를 통해 인스턴스가 만들어 질 때 호출되는 함수이다.
class 이름 (val name:String ...[속성을 뜻한다]){
    init{
        this.속성   //  인스턴스 자신의 속성이나 함수를 호출하기 위해 클래스 내부에서 사용되는 키워드
    }
}

기본 생성자 - 클래스를 만들 때 기본으로 선언하는
보조 생성자 - 필요에 따라 추가적으로 선언하는
기본 생성자와 다른형태의 생성자를 제공하여 인스턴스 생성시 편의를 제공하거나 추가적인 구문을 수행하는 기능을 제공하는 역할
class 이름 (val name:String ...[속성을 뜻한다]){
    init{
        this.속성   //  인스턴스 자신의 속성이나 함수를 호출하기 위해 클래스 내부에서 사용되는 키워드
    }
    constructor(속성이름: 속성변수형) : this(속성이름, 값){ // 보조생성자가 기본생성자를 호출하도록 하는 문구
        수행하는 기능
    }
}



10강
클래스의 상속
상속이 필요한 경우
1. 이미 존재하는 클래스를 확장하여 새로운 속성이나 함수를 추가
2. 여러개의 클래스의 공통점을 가진 클래스를 만들 때
수퍼 클래스 -> 서브 클래스

코틀린에서는 상속금지가 기본값이다.
open은 클래스가 상속될 수 있도록 클래스 선언시 붙여줄 수 있는 키워드 

ex)
class Animal(속성값들~){
    함수~

}
class Dog(var, val을 붙이면 속성으로 선언, 일반 패러미터로 수퍼클래스의 속성값들을 적준다. ): 수퍼클래스의 생성자[Animal(속성값들, "값")]{
    함수
}

상속 규칙
서브 클래스는 수퍼 클래스에 존재하는 속성과 같은이름의 속성을 가질 수 없다.
서브클래스가 생성될 때는 반드시 수퍼클래스의 생성자까지 호출되어야 한다.


11강
오버라이딩 추상화가능
오버라이딩 할 때 함수 앞에 open을 사용해 재구현을 허용하도록 하면 가능
override fun 함수명 (){}
추상화 // 단독으로는 instance화 시킬 수 없다.
abstract fun 함수명 () {}

코틀린에서는 인터페이스가 함수와 추상함수 둘다 가질 수 있지만
생성자가 없다.
별도의 키워드가 없어도 서브클래스에서 구현 및 재정의가 가능하다.
한번의 여러 클래스를 상속받을 수 있다.

interface Runner{
    fun run()
}
interface Eater{
    fun eat(){
        println()
    }
}
class Dog: Runner, Eater {
    override fun run(){
        println()
    }
    override fun eat(){
        println()

    }
}



12강 프로젝트
프로젝트는 어플리케이션에 관련한 모든 내용을 담는 큰 틀이라고 생각해라.
모듈은 패키지안에 여러개의 모듈이 있는데
직접만들 수 있고 필요한 기능을 이미 구현한 라이브러리를 가져와 사용할 수 있기 때문에 굉장히 편리한 기능 단위이다. 

모듈에는 코틀린 파일뿐만 아니라 모듈과 관련된 설정 및 리소스 파일 등도 포함 될 수 있다. 

논리적인 구조로 패키지가 있다.
package ~~
패키지는 개발시에 소스 코드의 소속을 지정하기 위한 논리적 단위이다.
패키지를 명시하지 않으면 default 패키지로 들어가게 된다.
코틀린은 자바와 달리 폴더구조와 패키지 명을 일치시키지 않아도 된다. 컴파일러가 아랑서 처리한다.
같은 패키지내의 파일들은 서로 호출할 수 있다.

다른 패키지의 함수, 변수를 사용할 수 있다.
import 외부패키지이름
중복되는 이름은 패키지를 포함한 풀 네임을 적어야 한다.

하나의 파일에 여러개의 클래스를 넣어도 컴파일이 가능하다.

파일이나 폴더를 기준으로 구분 x 패키지를 기준으로 구분




13강
프로젝트 구조 내에서 변수나 함수 클래스 공용범위를 제어하는 스코프와 스코프 내외부 접근제한을 하는 접근제한자

스코프
범위 - 언어차원에서 변수나 함수 클래스 같은 멤버들을 서로 공유하여 사용할 수 있는 범위를 지정하여 사용하는 것
패키지: 변수 함수 클래스
함수 : 변수, 함수
클래스 : 변수, 함수

스코프 세가지 규칙
1 스코프 외부에서는 스코프 내부의 멤버를 참조연산자로만 참조가 가능하다.
클래스의 멤버를 참조할 때 외부에서 인스턴스명에 참조연산자를 사용. (.)
2. 동일 스코프내에서는 멤버들을 공유할 수 있다.
ex)
val a = "패키지 스코프 "
class B {
    fun print(){
        println(a)
    }
}
fun main() {
    println(a)
    B().print()
}

3. 하위 스코프에서는 상위스코프의 멤버를 재 정의할 수 있다.
같은 레벨의 스코프에서는 같은 이름의 멤버를 만들면 안된다.
하위 스코프에서는 같은 이름의 멤버를 만들어 사용할 수 있다.


접근 제한자
스코프 외부에서 내부에 접근할 때 그 권한을 개발자가 제한할 수 있다
public 
protected
internal
private 

변수 함수 클래스 선언시 맨 앞에 붙여서
패키지 스코프에서는
public(기본값) / internal 같은 모듈내에서만 접근가능 / private 같은 파일 내에서만 접근가능
protected는 사용하지 않음
클래스 스코프에서는
public(기본값) / private 클래스 내부에서만 접근 가능 / protected 클래스 자신 및 상속받은 클래스에서 접근 가능



14강
특별한 함수형태인
고차함수와 람다함수

고차함수
함수를 마치 클래스에서 만들어낸 인스턴스처럼 취급하는 방식
코틀린에서는 모든 함수를 고차함수로 가능하다.
function : (파라미터 값) -> 반환값
ex) fun a(str:String){
    println("$str 함수 a")
    // 반환형이 없는 함수
}
fun b (function: (String)->Unit){
    function("b가 호출")
}
호출 법
b(::a)

이름을 붙이는게 아닌 바로 함수의 형식을 넘겨주는 것
람다함수
ex)
val c: (String) -> Unit = {str// 추론이 가능함. STring이라고 적어서 -> 기능식}
변수에 할당할 때는 타입추론 기능을 이용하여 축약해서 기술할 수 있다.

or
val c = {str:String -> 기능식}

컬렉션의 조작이나 스코프함수의 조작에도 도움이 된다.


15강
람다 함수의 특별한 경우
여러 구문을 수행할 수 있다.
ex)
마지막 구문이 결과값이 반환된다.

패러미터가 없는 람다함수 = 실행할 구문만

패러미터가 하나뿐이라면 


스코프 함수
함수형 언어의 특징을 좀 더 편리하게 사용할 수 있도록 기본 제공하는 함수
스코프 함수에 클래스의 인스턴스 속성이나 함수를 좀 더 깔끔하게 불러 사용하는 것
apply run with also let

apply
인스턴스를 생성하자 마자 참조연산자를 사용하여 중괄호를 람다함수를 만들어 scope안에서 직접 인스턴스의 속성과 함수를 참조연산자없이 사용가능하다.
인스턴스 자신을 다시 반환한다. = 변수에 바로 넣어줄 수 있다.
ex)
class Book(var name:String )


run
참조연산자를 사용하지 않아도 된다는 점은 같지만 일반 람다함수처럼 인스턴스대신 마지막 구문에 결과값을 반환한다. 인스턴스가 만들어진 후에 함수나 속성을 scope내에서 사용해야 할 때 유용하다.


with
run과 동일한 기능이지만 패러미터로 받는다.
with(a){...}

apply/also
참조연산자없이 인스턴스와 
run/let
패러미터로 인스턴스를 넘긴것 처럼 it을 통해서 사용할 수 있다.
같은 이름의 변수나 함수가 scope 바깥에 중복되어 있는 경우에 혼란을 방지하기 위함.


